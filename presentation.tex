%
% Functional Programming
%

\documentclass{beamer}

\title{Functional Programming in Haskell}
\subtitle{$\lambda$}

\author{Narendra Joshi \\
  \medskip
  narendraj9@gmail.com
}
\date{\today}

% Common packages
\usepackage{graphicx}
\usepackage{fancybox}
\usepackage{minted}
\usepackage{multicol}

%% Appearance
\usetheme{Madrid}
\renewcommand{\familydefault}{\sfdefault}

% graphics settings
\graphicspath{{./images/}}
\DeclareGraphicsExtensions{.png,.jpg}

\newenvironment{fimage}[2][\textheight]
               { \begin{figure}
                   \centering
                   \includegraphics[width=\textwidth, height=#1, keepaspectratio]{#2}
               }
               { \end{figure} }



\begin{document}

% Title
\begin{frame}
  \titlepage
\end{frame}

% Outline
\begin{frame}[t]
  \frametitle{Outline}

  \begin{itemize}
  \item{Functional view of the world}
  \item{Haskell and its brief history}
  \item{Perks of being a Haskeller}
  \item{Logistics of the workshop}
  \end{itemize}

\end{frame}

%% Education
\begin{frame}[c]
  \frametitle{The Enterprise of Education}
  \begin{block}{}
    \emph{ Education should prepare young people for jobs that do not
      yet exist, using technologies that have not been invented,
      to solve problems of which we are not yet aware.}
  \end{block}
\end{frame}

\section{Imperative and Functional Views of the World}

\begin{frame}[fragile,t]
  \frametitle{Imperative World by Example}

  % C code for adding numbers
  \inputminted[frame=lines,fontsize=\footnotesize,linenos=true]{c}{code/slides/sumfive.c}

  Let's think about it for a while.

  \begin{itemize}
  \item What is the model of computation in our mind?
  \item What are the elements that make up that model?
  \item Is it all relevant to our problem of adding up a sequence of numbers?
  \end{itemize}

\end{frame}

\begin{frame}[fragile,t]
  \frametitle{Functional World by Example}

  % Haskell code for adding numbers
  \inputminted[frame=lines,fontsize=\footnotesize,linenos=true]{haskell}{code/slides/SumFive.hs}

  Answers to previous questions for you:
  \begin{itemize}
  \item Computation by calculation. Not commands and their execution.
  \item Hides details of execution. Lets us have more time to think about the problem.
  \end{itemize}

\end{frame}

\begin{frame}[fragile,t]
  \frametitle{What gives?}

  \begin{multicols}{2}

    % Left column
    \inputminted[frame=lines,fontsize=\tiny]{c}{code/slides/sumfive.c}

    \begin{itemize}
    \item Book-keeping of events in time.
    \item Details of the machine spill up to our mental model.
    \end{itemize}

    \columnbreak

    % Right column
    \inputminted[frame=lines,fontsize=\tiny]{haskell}{code/slides/SumFiveShort.hs}

    \begin{itemize}
    \item Nice clean functional abstraction.
    \item Order of events that happen is based on data dependencies.
    \end{itemize}

  \end{multicols}

\end{frame}

% Yet another example
\begin{frame}[fragile,t]
  \frametitle{Yet Another Example}

  % C code
  \emph{Imperative Code}
  \inputminted[frame=lines,fontsize=\footnotesize]{c}{code/slides/primes.c}

  \vfill

  % Haskell code
  \emph{Functional Code}
  \inputminted[frame=lines,fontsize=\footnotesize]{haskell}{code/slides/Primes.hs}

\end{frame}

\begin{frame}[fragile,t]
  \frametitle{Key Points to Notice}

  \begin{multicols}{2}
    % C code column
    \emph{Imperative Code}
    \inputminted[frame=lines,fontsize=\tiny]{c}{code/slides/primes.c}

    \begin{itemize}
    \item Filtering primes and collecting them interwined. Looks more efficient.
    \item We lost modularity when the above two operations mixed, .i.e no separation of
      \textit{generation} from \textit{selection}.
    \end{itemize}

    \columnbreak

    % Haskell code column
    \emph{Functional Code}
    \inputminted[frame=lines,fontsize=\tiny]{haskell}{code/slides/Primes.hs}

    \begin{itemize}
    \item First filter primes from the sequence. Then pick two out of them. Perfect!
    \item Is it less efficient? Are you checking primality for every number in the range?
    \end{itemize}

  \end{multicols}
  \vfill
  \center{\emph{That's being lazy with style!}}

\end{frame}

% About Haskell
\begin{frame}[t]
  \frametitle{What's Haskell?}

  Haskell is
  \begin{itemize}
  \item{\bf Purely Funcional} \\
    \textit{You have definitions not assignments. No mutation.}

  \item{\bf Lazy} \\
    \textit{If something doesn't need to be computed, it will never be.}

  \item{\bf Higher Order} \\
    \textit{Functions are first-class people. Like values, they can be input to other functions.}

  \item{\bf General Purpose} \\
    \textit{It's not specific to any domain, e.g. SQL or html.}

  \end{itemize}
\end{frame}

\section{History of Haskell}

% History
\begin{frame}[t]
  \frametitle{A little bit of History}
  \texttt{Credits: Simon Peyton Jones}
  \begin{fimage}[18em]{beginnings} \end{fimage}
\end{frame}

\begin{frame}[t]
  \frametitle{A little bit of History}
  \texttt{Credits: Simon Peyton Jones}
  \begin{fimage}[18em]{haskell98} \end{fimage}
\end{frame}

\begin{frame}[t]
  \frametitle{History of Research Langauges}
  \texttt{Credits: Simon Peyton Jones}
  \begin{fimage}{historyResearchLang} \end{fimage}
\end{frame}

\begin{frame}[t]
  \frametitle{Successful Research Languages}
  \texttt{Credits: Simon Peyton Jones}
  \begin{fimage}{successfulRLang} \end{fimage}
\end{frame}

\begin{frame}[t]
  \frametitle{C++/Java/Perl/Ruby}
  \texttt{Credits: Simon Peyton Jones}
  \begin{fimage}{immortalLanguages} \end{fimage}
\end{frame}

\begin{frame}[t]
  \frametitle{Where's Haskell?}
  \texttt{Credits: Simon Peyton Jones}
  \begin{fimage}[18em]{haskellHistory} \end{fimage}
\end{frame}


% Perks of being a Haskeller
\section{Perks of Being a Haskeller}

\begin{frame}
  \frametitle{The Land of Haskell}

  \begin{itemize}
  \item Laziness lets us define potentially infinite datastructures, e.g. define the whole
    Fibonacci sequence rather than defining its $n^{th}$ element.
  \item Since there is no mutation, you can always replace equals by equals, i.e. rewriting code
    to make it better is easier [called refactoring].
  \item Do not repeat yourself mantra! Keep it *DRY* silly! Abstraction. Higher Order Functions.
    [Example mapping over a list] [wholemeal programming]
  \item Domain Specific Languages are easy to build upon Haskell, e.g. Euterpea for Music,
    Diagrams for drawing charts and diagams.
  \item You can prove that your code works! We'll do som simple proofs at the end of the workshop.
  \item It's a vehicle to learn functional programming techniques. The long term principles.
  \end{itemize}

\end{frame}

\begin{frame}[t]
  \frametitle{The Land of Haskell}

  Who's using a functional languages?

  \begin{itemize}
  \item Facebook (Haskell)
  \item Twitter (Scala)
  \item Yahooo (Lisp and Erlang)
  \item Microsoft (GHC FSharp)
  \item Google (MapReduce)
  \item Ericsson (Erlang)
  \item Banks and Trading Firms: Morgan Stanley, Standerd Chartered, Jane Street Capital
  \end{itemize}

\end{frame}


\begin{frame}[t]
  \frametitle{Concepts that languages borrowed from the Functional World}

  \begin{itemize}
  \item Garbage Collection (Java, Python, Ruby, Javascript)
  \item Higher Order Functions (Python, Javascript)
  \item Generics (Java, C++)
  \item List Comprehensions (Python, Javascript)
  \end{itemize}

  So, it's reasonable to say that Haskell holds within itself the next big thing.
\end{frame}

\begin{frame}
  \frametitle{Time to start Coding}
  Code, Resources, Slides: \url{https://github.com/narendraj9/fp-nith}
  IRC: Freenode \#fp@nith

  \center{See you tomorrow!}

\end{frame}

\end{document}
